<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Optimizador TÃ©cnico de Cortes â€” Completo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1720; --text:#e6eef6; --muted:#98a2b3;
    --accent:#2ec4b6; --accent-2:#2b6df6; --danger:#ef4444; --border:#263039;
  }
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#071017,#071a2a);color:var(--text)}
  header{background:linear-gradient(90deg,var(--accent-2),#0366a6);padding:14px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid rgba(0,0,0,0.2)}
  header h1{margin:0;font-size:18px;color:#fff}
  .wrap{max-width:1200px;margin:18px auto;padding:12px}
  .panel{background:linear-gradient(180deg,#071820,#061017);border-radius:10px;padding:14px;border:1px solid var(--border)}
  label{color:var(--muted);font-size:13px}
  input, select, button, textarea{font-size:14px}
  input[type="text"], input[type="number"], select, textarea{width:100%;padding:8px;border-radius:6px;border:1px solid #22303a;background:#071018;color:var(--text)}
  table{width:100%;border-collapse:collapse;margin-top:10px;background:transparent}
  th,td{padding:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px;color:var(--text);text-align:center}
  th{background:rgba(255,255,255,0.03);color:var(--muted)}
  .row{display:flex;gap:10px}
  .col{flex:1}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .btn{background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#041018;padding:8px 12px;border-radius:6px;border:none;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
  .btn.danger{background:var(--danger);color:#fff}
  #summary{margin-top:12px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#071319,#061018);color:var(--text)}
  .muted{color:var(--muted);font-size:13px}
  .login-box{max-width:520px;margin:80px auto;padding:18px;border-radius:10px;background:linear-gradient(180deg,#071014,#081218);border:1px solid var(--border)}
  .center{text-align:center}
  .small{font-size:12px;color:var(--muted)}
  @media(max-width:860px){ .row{flex-direction:column} .col{width:100%} }
</style>
</head>
<body>
<header>
  <h1>ðŸ”© Optimizador TÃ©cnico de Cortes â€” VersiÃ³n Final</h1>
  <div id="hdrUser" class="small">Offline â€¢ Tema tÃ©cnico</div>
</header>

<div class="wrap">
  <!-- LOGIN -->
  <div id="loginSection" class="login-box panel">
    <h2 style="color:var(--text);margin:0 0 8px 0">Acceso</h2>
    <div class="row" style="gap:8px">
      <div class="col">
        <label>Usuario (nombre):</label>
        <input id="loginUser" type="text" placeholder="Ej. Gustavo Chamorro">
      </div>
      <div style="width:180px">
        <label>ContraseÃ±a:</label>
        <input id="loginPass" type="password" placeholder="ContraseÃ±a">
      </div>
    </div>
    <div style="margin-top:12px" class="actions">
      <button class="btn" id="loginBtn">Entrar</button>
    </div>
    <p class="small" style="margin-top:10px;color:var(--muted)">ContraseÃ±a fija por defecto: <b>1234</b></p>
  </div>

  <!-- APP -->
  <div id="appSection" style="display:none">
    <div class="panel">
      <div class="row" style="align-items:center;gap:12px">
        <div class="col">
          <label>Proyecto / Cliente</label>
          <input id="projectName" type="text" placeholder="Ej. Proyecto Alfa - Edificio A">
        </div>
        <div style="width:260px">
          <label>Largo disponible de tira (mm)</label>
          <input id="globalLargo" type="text" value="6000" placeholder="Ej: 6000,5000" >
        </div>
        <div style="width:260px">
          <label>&nbsp;</label>
          <div class="actions">
            <button class="btn" onclick="addRow()">âž• Agregar ventana</button>
            <button class="btn ghost" onclick="calcular()">ðŸ§® Calcular resumen</button>
            <button class="btn" onclick="exportPdf()">ðŸ“„ Exportar PDF</button>
            <button class="btn danger" onclick="borrarTodo()">ðŸ—‘ Borrar todo</button>
          </div>
        </div>
      </div>

      <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>

      <div id="summary" class="muted center">Presiona "Calcular resumen" para ver totales por perfil.</div>

      <table id="tableWindows">
        <thead>
          <tr>
            <th>ID Ventana</th>
            <th>Ancho (mm)</th>
            <th>Alto (mm)</th>
            <th>Cantidad</th>
            <th>Sistema</th>
            <th>Largo Tira (mm) [override]</th>
            <th>Eliminar</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

    </div>
  </div>
</div>

<script>
/* ----------------- CONFIG ----------------- */
const PASSWORD = "1234";
const MERMA = 50; // merma por corte en mm
let currentUser = null;
let lastResults = null;

const SYSTEMS = {
  "Corrediza Europea 3 Hojas": {
    "MTG1399": { altos: 2, anchos: 2 },
    "MTG2177": { altos: 4, anchos: 4, dividirAncho: true },
    "MTG2176": { altos: 4, anchos: 0 },
    "F04": { tipo: "herraje", calcularSegun: { "MTG2177": 2, "MTG2176": 1 } },
    "EUAA05L": { cantidad: 20, tipo: "herraje" },
    "EUAP01": { cantidad: 1.5, tipo: "herraje" },
    "EUCH01": { cantidad: 2, tipo: "herraje" },
    "EUCH02": { cantidad: 2, tipo: "herraje" },
  },
  "Fija": {
    "MTG2180": { altos: 2, anchos: 2 },
    "MTG2184": { altos: 2, anchos: 2 },
    "EUAA01": { cantidad: 4, tipo: "herraje" },
  },
  "Batiente": {},
  "ProyecciÃ³n": {},
  "Otro": {}
};

/* ----------------- UTILIDADES ----------------- */
function colorForId(id){
  const hash = [...String(id)].reduce((a,c)=>a+c.charCodeAt(0),0);
  const hue = hash % 360;
  return hslToRgb(hue/360,0.65,0.5);
}
function hslToRgb(h, s, l){
  let r,g,b;
  if(s==0){ r=g=b=l; }
  else{
    const hue2rgb=(p,q,t)=>{ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; };
    const q = l < 0.5 ? l*(1+s) : l+s-l*s;
    const p = 2*l-q;
    r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}

/* ----------------- LOGIN ----------------- */
document.getElementById('loginBtn').addEventListener('click', () => {
  const u = document.getElementById('loginUser').value.trim();
  const p = document.getElementById('loginPass').value;
  if(!u || !p){ alert('Ingrese usuario y contraseÃ±a'); return; }
  if(p !== PASSWORD){ alert('ContraseÃ±a incorrecta'); document.getElementById('loginPass').value = ''; return; }
  currentUser = u;
  document.getElementById('hdrUser').innerText = `Usuario: ${u}`;
  document.getElementById('loginSection').style.display = 'none';
  document.getElementById('appSection').style.display = 'block';
  addRow();
});

/* ----------------- INTERFAZ (tabla) ----------------- */
function addRow(){
  const tbody = document.querySelector('#tableWindows tbody');
  const tr = document.createElement('tr');
  const defaultLargo = document.getElementById('globalLargo').value || '6000';
  tr.innerHTML = `
    <td><input type="text" placeholder="V1"></td>
    <td><input type="number" placeholder="1000"></td>
    <td><input type="number" placeholder="1500"></td>
    <td><input type="number" value="1" min="1"></td>
    <td><select>${Object.keys(SYSTEMS).map(s=>`<option value="${s}">${s}</option>`).join('')}</select></td>
    <td><input type="text" value="${defaultLargo}" placeholder="Opcional: 6000,5000"></td>
    <td><button class="btn ghost" onclick="this.closest('tr').remove()">X</button></td>
  `;
  tbody.appendChild(tr);
}

// GLOBAL: lista de sobrantes disponibles
let sobrantesGlobales = [];

/* ----------------- SOLVER MULTI-LARGO (BFD con uso de sobrantes y merma consistente) ----------------- */
function solveCutsMultiLargo(piezas, largosDisponibles, merma = MERMA){
  if(!piezas || piezas.length === 0) return [];
  // normalizar largos disponibles (desc)
  const largos = Array.from(new Set((largosDisponibles||[]).map(v=>parseInt(v)).filter(n=>!isNaN(n) && n>0))).sort((a,b)=>b-a);
  if(largos.length === 0) largos.push(6000);

  // ordenar piezas desc por largo (heavier first)
  const lista = piezas.slice().map(p=>({ winId: p.winId, len: Number(p.len) })).filter(p=>p.len>0);
  lista.sort((a,b)=>b.len - a.len);

  const bins = []; // cada bin: { largo, piezas:[{winId,len}], restante, utilizada }

  // Helper: intentar colocar en el mejor sobrante (el que deja menor resto)
  function placeInSobrantes(pieza) {
    let bestIdx = -1;
    let bestRest = Infinity;
    const need = pieza.len + merma;
    for(let i=0;i<sobrantesGlobales.length;i++){
      const s = sobrantesGlobales[i];
      if(s >= need && (s - need) < bestRest){
        bestRest = s - need;
        bestIdx = i;
      }
    }
    if(bestIdx >= 0){
      sobrantesGlobales[bestIdx] -= need;
      if(sobrantesGlobales[bestIdx] < 20) sobrantesGlobales.splice(bestIdx,1);
      return true;
    }
    return false;
  }

  // Helper: intentar colocar en el mejor bin existente
  function placeInBestBin(pieza){
    let best = null; let bestRest = Infinity;
    const need = pieza.len + merma;
    for(const b of bins){
      if(b.restante >= need){
        const r = b.restante - need;
        if(r < bestRest){
          bestRest = r; best = b;
        }
      }
    }
    if(best){
      best.piezas.push({ winId: pieza.winId, len: pieza.len });
      best.restante -= need;
      best.utilizada += pieza.len;
      return true;
    }
    return false;
  }

  // InserciÃ³n principal
  for(const pieza of lista){
    if(placeInSobrantes(pieza)) continue;
    if(placeInBestBin(pieza)) continue;

    // crear nueva tira con el menor largo que quepa
    const need = pieza.len + merma;
    let chosen = null;
    for(const L of largos.slice().sort((a,b)=>a-b)){
      if(L >= need){ chosen = L; break; }
    }
    if(!chosen) chosen = Math.max(need, largos[0] || 6000);

    const nueva = {
      piezas: [{ winId: pieza.winId, len: pieza.len }],
      largo: chosen,
      restante: chosen - need,
      utilizada: pieza.len
    };
    bins.push(nueva);
  }

  // Mejora local (mover piezas pequeÃ±as para llenar mejor tiras)
  const maxPasses = 3;
  for(let pass=0; pass<maxPasses; pass++){
    let moved=false;
    const targets = bins.slice().sort((a,b)=>b.restante - a.restante);
    for(const target of targets){
      for(const donor of bins){
        if(donor === target) continue;
        donor.piezas.sort((a,b)=>a.len - b.len);
        for(let i=0;i<donor.piezas.length;i++){
          const p = donor.piezas[i];
          const need = p.len + merma;
          if(target.restante >= need){
            donor.piezas.splice(i,1);
            donor.restante += need;
            donor.utilizada -= p.len;

            target.piezas.push({ winId: p.winId, len: p.len });
            target.restante -= need;
            target.utilizada += p.len;

            moved = true;
            break;
          }
        }
        if(moved) break;
      }
    }
    if(!moved) break;
  }

  // Guardar sobrantes grandes
  for(const b of bins){
    if(b.restante > 20) sobrantesGlobales.push(b.restante);
  }

  bins.forEach((b,i)=>{ b.id = i+1; b.utilizada = b.utilizada || b.piezas.reduce((a,p)=>a+p.len,0); });
  return bins;
}
 // FUNCION CALCULAR AQUI SE EMPIEZAN A CALCULAAR TIRAS
function calcular(){
  const filas = [...document.querySelectorAll('#tableWindows tbody tr')];
  if(filas.length === 0){ alert('Agrega al menos una ventana'); return; }

  // leer largos globales
  const rawLargos = (document.getElementById('globalLargo').value || '6000').split(',').map(s=>s.trim()).filter(s=>s.length>0);
  const largosDisponiblesGlobal = Array.from(new Set(rawLargos.map(v => parseInt(v)).filter(n=>!isNaN(n) && n>0))).sort((a,b)=>b-a);
  if(largosDisponiblesGlobal.length === 0) largosDisponiblesGlobal.push(6000);

  // reset global sobrantes al comenzar un cÃ¡lculo limpio
  sobrantesGlobales = [];

  const resumenPorPerfil = {};
  const tirasPorPerfil = {}; // perfil -> { tiras: [], largosUsados: [] }
  const resumenHerrajes = {};
  const resumenVentanas = {}; // winId -> { ancho, alto, qty }
  const piezasPorPerfil = {}; // temporal: perfil -> { piezas: [{winId,len}], largosSet: Set() }

  let totalUsado = 0;
  let totalDisponible = 0;
  const resumenPorLargo = {}; // largo -> count

  // --- PRIMER PASO: recolectar TODAS las piezas por perfil (de todas las filas) ---
  for(const tr of filas){
    const tds = tr.querySelectorAll('td');
    const winId = tds[0].querySelector('input').value.trim() || '-';
    const ancho = parseFloat(tds[1].querySelector('input').value) || 0;
    const alto = parseFloat(tds[2].querySelector('input').value) || 0;
    const qty = parseInt(tds[3].querySelector('input').value) || 1;
    const sistema = tds[4].querySelector('select').value;
    const rawRow = (tds[5].querySelector('input').value || '').split(',').map(s=>s.trim()).filter(s=>s.length>0);
    const rowLargos = Array.from(new Set(rawRow.map(v=>parseInt(v)).filter(n=>!isNaN(n) && n>0)));

    // registrar ventana en resumen de ventanas
    if(!resumenVentanas[winId]) resumenVentanas[winId] = { ancho, alto, qty: 0 };
    resumenVentanas[winId].qty += qty;

    const sys = SYSTEMS[sistema];
    if(!sys) continue;

    for(const [perfil, def] of Object.entries(sys)){
      if(def.tipo === "herraje"){
        // herraje directo: contabilizar por ventana
        const cantidadVentanas = qty;
        const cantidadTotal = (def.cantidad || 1) * cantidadVentanas;
        resumenHerrajes[perfil] = (resumenHerrajes[perfil] || 0) + cantidadTotal;
        continue;
      }

      // construir cortes por perfil (para esta ventana)
      const cortesBase = [];
      for(let i=0;i<(def.altos||0);i++) cortesBase.push(alto);
      const anchoCorte = def.dividirAncho ? (ancho/2) : ancho;
      for(let j=0;j<(def.anchos||0);j++) cortesBase.push(anchoCorte);
      if(cortesBase.length === 0) continue;

      // replicar por cantidad
      const cortesTotales = [];
      for(let k=0;k<qty;k++) cortesTotales.push(...cortesBase);

      // inicializar estructura por perfil si no existe
      piezasPorPerfil[perfil] = piezasPorPerfil[perfil] || { piezas: [], largosSet: new Set() };

      // aÃ±adir largos de fila si hay override; si no, se usarÃ¡ el global mÃ¡s adelante
      if(rowLargos.length){
        rowLargos.forEach(L=>piezasPorPerfil[perfil].largosSet.add(L));
      } else {
        // para mantener compatibilidad, tambiÃ©n incluimos los globales en el set
        largosDisponiblesGlobal.forEach(L=>piezasPorPerfil[perfil].largosSet.add(L));
      }

      // aÃ±adir piezas referenciadas a esta ventana
      cortesTotales.forEach(len => piezasPorPerfil[perfil].piezas.push({ winId, len }));
    }
  }

  // --- SEGUNDO PASO: resolver por cada perfil (una sola llamada al solver por perfil) ---
  for(const [perfil, info] of Object.entries(piezasPorPerfil)){
    const piezas = info.piezas || [];
    if(piezas.length === 0) continue;

    // preparar largos a usar: preferimos los largos recogidos por fila (si se usaron overrides),
    // si no hay especÃ­ficos, usamos los globales.
    let largosParaPerfil = Array.from(info.largosSet).filter(n=>!isNaN(n) && n>0);
    if(largosParaPerfil.length === 0) largosParaPerfil = largosDisponiblesGlobal.slice();

    // ordenar y eliminar duplicados
    largosParaPerfil = Array.from(new Set(largosParaPerfil)).sort((a,b)=>b-a);

    // llamar al solver una vez por perfil con el conjunto completo de piezas
    const bins = solveCutsMultiLargo(piezas, largosParaPerfil, MERMA);

    // acumular por perfil
    resumenPorPerfil[perfil] = (resumenPorPerfil[perfil] || 0) + bins.length;
    tirasPorPerfil[perfil] = tirasPorPerfil[perfil] || { tiras: [], largosUsados: [] };

    bins.forEach(b => {
      // estandarizar estructura: piezas: [{winId,len}], restante, largo, utilizada
      const piezasCopy = (b.piezas || []).map(p=>({ winId: p.winId, len: p.len }));
      const restante = Math.max(0, Math.round(b.restante || 0));
      const largoUsed = b.largo || ((largosParaPerfil && largosParaPerfil[0]) || 6000);
      const utilizada = b.utilizada || piezasCopy.reduce((a,p)=>a+p.len,0);

      tirasPorPerfil[perfil].tiras.push({
        piezas: piezasCopy,
        restante,
        largo: largoUsed,
        utilizada
      });
      tirasPorPerfil[perfil].largosUsados.push(largoUsed);

      resumenPorLargo[largoUsed] = (resumenPorLargo[largoUsed] || 0) + 1;

      totalUsado += utilizada;
      // cuando contamos totalDisponible, consideramos (largo - MERMA) por tira como ya estabas haciendo
      totalDisponible += Math.max(largoUsed - MERMA, 0);
    });
  }

  // calcular herrajes dependientes (calcularSegun) â€” igual que antes
  for(const [nombreSistema, perfiles] of Object.entries(SYSTEMS)){
    for(const [perfil, def] of Object.entries(perfiles)){
      if(def.tipo === "herraje" && def.calcularSegun){
        let totalMetros = 0;
        for(const [basePerfil, factor] of Object.entries(def.calcularSegun)){
          const tirasBase = (tirasPorPerfil[basePerfil] && tirasPorPerfil[basePerfil].tiras) || [];
          let sumaMm = 0;
          tirasBase.forEach(tira => sumaMm += tira.piezas.reduce((a,b)=>a + b.len,0));
          const metros = sumaMm / 1000;
          totalMetros += metros * factor;
        }
        resumenHerrajes[perfil] = Math.round(totalMetros * 100) / 100;
      }
    }
  }

  // sumar herrajes directos si aparecen en resumenPorPerfil (seguridad)
  for(const [perfil, cantidad] of Object.entries(resumenPorPerfil)){
    let isHerraje = false;
    for(const sys of Object.values(SYSTEMS)){
      if(sys[perfil]?.tipo === "herraje") { isHerraje = true; break; }
    }
    if(isHerraje){
      resumenHerrajes[perfil] = (resumenHerrajes[perfil] || 0) + cantidad;
    }
  }

  const aprovechamiento = totalDisponible > 0 ? (totalUsado / totalDisponible) * 100 : 0;

  lastResults = {
    proyecto: document.getElementById('projectName').value || '',
    usuario: currentUser,
    resumenPorPerfil,
    tirasPorPerfil,
    resumenHerrajes,
    resumenVentanas,
    resumenPorLargo,
    aprovechamiento,
    totalUsado,
    totalDisponible
  };

  // construir HTML resumen ARRIBA (igual que antes)
  let html = `<b>Resumen â€” Tiras totales por perfil</b><br>`;
  if(Object.keys(resumenPorPerfil).length === 0) html += '<span class="muted">No hay perfiles (tal vez solo herrajes o datos faltantes)</span>';
  else {
    Object.entries(resumenPorPerfil).forEach(([perfil, cant]) => {
      html += `${perfil}: ${cant} tiras<br>`;
    });
  }

  html += `<br><b>Resumen por largo de tira:</b><br>`;
  if(Object.keys(resumenPorLargo).length === 0) html += '<span class="muted">No hay tiras calculadas</span>';
  else {
    Object.keys(resumenPorLargo).map(k=>parseInt(k)).sort((a,b)=>b-a).forEach(l => {
      html += `${resumenPorLargo[l]} tiras de ${l} mm<br>`;
    });
  }

  const totalTiras = Object.values(resumenPorLargo).reduce((a,b)=>a+b,0);
  const totalSobrante = Math.max(0, Math.round((totalDisponible - totalUsado)));
  html += `<br><b>Total de tiras:</b> ${totalTiras}<br>`;
  html += `<b>Total sobrante (mm estimado):</b> ${totalSobrante} mm<br>`;
  html += `<b>Aprovechamiento total:</b> ${aprovechamiento.toFixed(2)}%`;

  document.getElementById('summary').innerHTML = html;
}

 function exportPdf(){
  if(!lastResults || !lastResults.tirasPorPerfil){ alert('Primero presiona Calcular resumen.'); return; }

  try {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation:'landscape', unit:'pt', format:'a4' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 36;
    let y = margin;

    // Encabezado
    doc.setFontSize(16);
    doc.setTextColor(20,120,90);
    doc.text('OPTIMIZADOR DE CORTES - REPORTE TÃ‰CNICO', pageW/2, y, {align:'center'});
    y += 22;

    doc.setFontSize(10);
    doc.setTextColor(0,0,0);
    doc.text(`Proyecto: ${lastResults.proyecto || '-'}`, margin, y);
    doc.text(`Usuario: ${lastResults.usuario || '-'}`, margin + 300, y);
    doc.text(`Fecha: ${new Date().toLocaleString()}`, pageW - margin - 200, y);
    y += 14;

    // Resumen de Herrajes
    doc.setFontSize(11);
    doc.text('RESUMEN DE HERRAJES Y ACCESORIOS', margin, y);
    y += 10;
    doc.setFontSize(9);
    const herrajesEntries = Object.entries(lastResults.resumenHerrajes || {});
    if(herrajesEntries.length === 0){
      doc.text('No se registraron herrajes.', margin, y); y += 10;
    } else {
      herrajesEntries.forEach(([codigo, valor])=>{
        doc.text(`${codigo}: ${Number(valor).toFixed(2)}`, margin, y); y += 8;
      });
    }
    y += 6;

    // Resumen de Ventanas
    doc.setFontSize(11);
    doc.text('RESUMEN DE VENTANAS (ID = Ancho x Alto, Cantidad)', margin, y);
    y += 10;
    doc.setFontSize(9);
    const ventanasEntries = Object.entries(lastResults.resumenVentanas || {});
    if(ventanasEntries.length === 0){
      doc.text('No hay ventanas registradas.', margin, y); y += 10;
    } else {
      ventanasEntries.forEach(([id, o])=>{
        const an = o.ancho || '-';
        const al = o.alto || '-';
        const qt = o.qty || 0;
        doc.text(`${id} = Ancho: ${an} mm, Alto: ${al} mm, Cantidad: ${qt}`, margin, y);
        y += 8;
      });
    }
    y += 8;

    // Resumen por largo
    doc.setFontSize(11);
    doc.text('RESUMEN DE TIRAS POR LARGO', margin, y);
    y += 10;
    doc.setFontSize(9);
    const resumenPorLargo = lastResults.resumenPorLargo || {};
    if(Object.keys(resumenPorLargo).length === 0){
      doc.text('No se registraron tiras.', margin, y); y += 10;
    } else {
      Object.keys(resumenPorLargo).map(k=>parseInt(k)).sort((a,b)=>b-a).forEach(l => {
        doc.text(`${resumenPorLargo[l]} tiras de ${l} mm`, margin, y); y += 8;
      });
    }
    y += 8;

    // Aprovechamiento
    doc.setFontSize(11);
    doc.setTextColor(0,100,0);
    doc.text(`Aprovechamiento total del material: ${(lastResults.aprovechamiento || 0).toFixed(2)}%`, margin, y);
    doc.setTextColor(0,0,0);
    y += 14;

    // Diagramas por perfil (robusto)
    const barMaxWidth = Math.min(pageW - margin*2 - 220, 1000);
    const barH = 18;
    const gap = 48;
    const perfilGap = 16;
    const containerX = margin + 160;
    const containerW = barMaxWidth;

    const profiles = lastResults.tirasPorPerfil || {};
    for(const [perfil, obj] of Object.entries(profiles)){
      const tiras = (obj && obj.tiras) ? obj.tiras : [];
      if(tiras.length === 0) continue;

      if(y > pageH - 160){ doc.addPage(); y = margin; }
      doc.setFontSize(12);
      doc.setTextColor(0,0,0);
      doc.text(`${perfil} â€” Diagramas de corte`, margin, y);
      y += 12;

      for(let i=0;i<tiras.length;i++){
        const tira = tiras[i] || {};
        // garantÃ­as de campos
        tira.piezas = Array.isArray(tira.piezas) ? tira.piezas : [];
        tira.utilizada = Number(tira.utilizada) || tira.piezas.reduce((a,p)=>a + (Number(p.len)||0), 0);
        tira.restante = Number(tira.restante);
        if(isNaN(tira.restante)) {
          // calcular sobrante si no existe (seguridad)
          const capacidadTemp = Number(tira.largo) || parseInt((document.getElementById('globalLargo').value||'6000').split(',')[0]) || 6000;
          tira.restante = Math.max(0, capacidadTemp - tira.utilizada - MERMA);
        }
        const capacidad = Number(tira.largo) || parseInt((document.getElementById('globalLargo').value||'6000').split(',')[0]) || 6000;
        const safeCapacidad = capacidad > 0 ? capacidad : 6000;
        const scale = (safeCapacidad > 0) ? (barMaxWidth / safeCapacidad) : 1;

        // reservar espacio en pÃ¡gina
        const neededSpace = barH + gap;
        if(y + neededSpace > pageH - 80){
          doc.addPage();
          y = margin;
        }

        // label tira
        doc.setFontSize(9);
        doc.text(`Tira ${i+1} (${safeCapacidad} mm)`, margin + 120, y + barH/2 + 3, {align:'right'});

        // marco
        doc.setDrawColor(120);
        doc.rect(containerX, y, containerW, barH);

        // dibujar piezas (control overflow)
        let x = containerX;
        for(let ci=0; ci<tira.piezas.length; ci++){
          const pieza = tira.piezas[ci] || {};
          const piezaLen = Number(pieza.len) || 0;
          // ancho visual mÃ­nimo para que se vea
          const rawSeg = Math.max(2, Math.round(piezaLen * scale));
          const maxAllowed = Math.max(0, containerX + containerW - x);
          const seg = Math.max(0, Math.min(rawSeg, maxAllowed));
          if(seg <= 0) break;

          const color = colorForId(pieza.winId || '');
          doc.setFillColor(color[0], color[1], color[2]);
          doc.rect(x, y, seg, barH, 'F');

          doc.setFontSize(7);
          if(seg > 50){
            doc.setTextColor(255,255,255);
            const etiqueta = `${pieza.winId || '-'} - ${piezaLen} mm`;
            doc.text(etiqueta, x + seg/2, y + barH/2 + 3, {align:'center'});
          } else {
            doc.setTextColor(0,0,0);
            doc.text(`${piezaLen} mm`, x + seg/2, y - 4, {align:'center'});
          }

          x += seg;
          if(x >= containerX + containerW - 1) break;
        }

        // sobrante
        const sobranteReal = Math.max(0, Math.round(tira.restante || (safeCapacidad - tira.utilizada - MERMA)));
        if(sobranteReal > 0 && x < containerX + containerW - 2){
          const sobraW = Math.round(sobranteReal * scale);
          const maxAllowed = containerX + containerW - x;
          const finalSobraW = Math.min(sobraW, Math.max(0, Math.round(maxAllowed)));
          if(finalSobraW > 0){
            doc.setFillColor(200,200,200);
            doc.rect(x, y, finalSobraW, barH, 'F');
            doc.setFontSize(8);
            doc.setTextColor(0,0,0);
            if(finalSobraW > 60){
              doc.text(`Sobrante ${tira.restante} mm`, x + finalSobraW/2, y + barH/2 + 3, {align:'center'});
            } else {
              doc.text(`Sobrante ${tira.restante} mm`, x + Math.max(10, finalSobraW/2), y - 4, {align:'center'});
            }
          }
        }

        // etiqueta utilizada
        doc.setFontSize(8);
        doc.setTextColor(0,0,0);
        doc.text(`Tira utilizada: ${tira.utilizada} mm`, containerX + containerW/2, y + barH + 14, {align:'center'});

        y += gap;
        if(y > pageH - 100){ doc.addPage(); y = margin; }
      }

      y += perfilGap;
    }

    // guardar
    doc.save(`Cortes_${(new Date()).toISOString().slice(0,19).replace(/[:T]/g,'_')}.pdf`);
    console.log('Export PDF: OK');
  } catch(err) {
    console.error('Error en exportPdf:', err);
    alert('OcurriÃ³ un error al generar el PDF. Revisa la consola para mÃ¡s detalles.');
  }
}

/* ----------------- UTIL ----------------- */
function borrarTodo(){
  if(!confirm('Â¿Borrar todo?')) return;
  document.querySelector('#tableWindows tbody').innerHTML = '';
  lastResults = null;
  document.getElementById('summary').innerText = 'Presiona "Calcular resumen" para ver totales por perfil.';
}
</script>
</body>
</html>
