<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Optimizador Técnico de Cortes (Final con Resumen y Etiquetas de Tira)</title>
<title>Optimizador Técnico de Cortes — Completo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  :root{
    --bg:#111317;
    --panel:#1b1f23;
    --card:#0f1720;
    --text:#e6eef6;
    --muted:#98a2b3;
    --accent:#2ec4b6;
    --danger:#ef4444;
    --border:#2a2f33;
    --bg:#111317; --panel:#1b1f23; --text:#e6eef6; --muted:#98a2b3; --accent:#2ec4b6; --danger:#ef4444; --border:#2a2f33;
  }
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#0b0d0f, #0f1315);color:var(--text)}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#0b0d0f,#0f1315);color:var(--text)}
  header{background:#071017;padding:14px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border)}
  header h1{margin:0;font-size:18px;color:var(--accent)}
  .wrap{max-width:1200px;margin:18px auto;padding:12px}
  .panel{background:linear-gradient(180deg,#0f1720,#0b1013);border-radius:10px;padding:14px;border:1px solid var(--border);box-shadow:0 6px 24px rgba(0,0,0,0.6)}
  .panel{background:linear-gradient(180deg,#0f1720,#0b1013);border-radius:10px;padding:14px;border:1px solid var(--border)}
  label{color:var(--muted);font-size:13px}
  input, select, button, textarea{font-size:14px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;padding:8px;border-radius:6px;border:1px solid #22303a;background:#071018;color:var(--text)
  }
  input[type="text"], input[type="number"], select, textarea{width:100%;padding:8px;border-radius:6px;border:1px solid #22303a;background:#071018;color:var(--text)}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px;border:1px solid var(--border);font-size:13px;color:var(--text);text-align:center;background:transparent}
  th,td{padding:8px;border:1px solid var(--border);font-size:13px;color:var(--text);text-align:center}
  th{background:#071820;color:var(--muted)}
  .row{display:flex;gap:10px}
  .col{flex:1}
@@ -115,14 +106,18 @@ <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>
</div>

<script>
/* ----------------- CONFIG ----------------- */
const PASSWORD = "1234";
const MERMA = 50;
const MERMA = 50; // merma por corte en mm
let currentUser = null;
let lastResults = null;

const SYSTEMS = {
  "Corrdiza Europea 3 Hojas": {
    "MTG1399": { altos: 2, anchos: 2 },
    "MTG2177": { altos: 4, anchos: 4, dividirAncho: true }, // solo este divide el ancho
    "MTG2176": { altos: 4, anchos: 0 },
    "F04": { tipo: "herraje", calcularSegun: { "MTG2177": 2, "MTG2176": 1 } },
    "F04": { tipo: "herraje", calcularSegun: { "MTG2177": 2, "MTG2176": 1 } }, // calculado según metros lineales de perfiles
    "EUAA05L": { cantidad: 20, tipo: "herraje" },
    "EUAP01": { cantidad: 1.5, tipo: "herraje" },
    "EUCH01": { cantidad: 2, tipo: "herraje" },
@@ -132,129 +127,96 @@ <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>
    "MTG2180": { altos: 2, anchos: 2 },
    "MTG2184": { altos: 2, anchos: 2 },
    "EUAA01": { cantidad: 4, tipo: "herraje" },
    },
  "Corrdiza Europea con Cedazo": {
    "MTG1399": { altos: 2, anchos: 2 },
    "MTG2177": { altos: 4, anchos: 4, dividirAncho: true }, // solo este divide el ancho
    "MTG2078": { altos: 2, anchos: 2, dividirAncho: true }, // solo este divide el ancho
    "MTG2176": { altos: 2, anchos: 0 },
    "F04": { tipo: "herraje", calcularSegun: { "MTG2177": 2, "MTG2176": 1, "MTG20782": 2 } },
    "E04EUN": { tipo: "herraje", calcularSegun: { "MTG2078": 2 } },
    "EUAA05L": { cantidad: 20, tipo: "herraje" },
    "EUAP01": { cantidad: 1.5, tipo: "herraje" },
    "EUCH01": { cantidad: 2, tipo: "herraje" },
    "EUCH02": { cantidad: 2, tipo: "herraje" },
    "EMPAQUE SEGUN VIDRIO": { tipo: "herraje", calcularSegun: { "MTG2177": 1 } },
  },
  "Batiente": {},
  "Proyección": {},
  "Otro": {}
};

let lastResults = null;
let currentUser = null;

// --- UTILIDADES DE COLOR ---
/* ----------------- UTILIDADES ----------------- */
function colorForId(id){
  const hash = [...id].reduce((a,c)=>a+c.charCodeAt(0),0);
  const hue = hash % 360;
  const rgb = hslToRgb(hue/360,0.6,0.5);
  return rgb;
}
function hslToRgb(h, s, l){
  let r, g, b;
  if(s == 0){ r = g = b = l; }
  let r,g,b;
  if(s==0){ r=g=b=l; }
  else{
    const hue2rgb = (p,q,t)=>{
      if(t<0)t+=1;if(t>1)t-=1;
      if(t<1/6)return p+(q-p)*6*t;
      if(t<1/2)return q;
      if(t<2/3)return p+(q-p)*(2/3-t)*6;
      return p;
    }
    const hue2rgb=(p,q,t)=>{ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; };
    const q = l < 0.5 ? l*(1+s) : l+s-l*s;
    const p = 2*l-q;
    r = hue2rgb(p,q,h+1/3);
    g = hue2rgb(p,q,h);
    b = hue2rgb(p,q,h-1/3);
    r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}

// --- LOGIN ---
/* ----------------- LOGIN ----------------- */
function doLogin(){
  const u = document.getElementById('loginUser').value.trim();
  const p = document.getElementById('loginPass').value;
  if(!u || !p){ alert('Ingrese usuario y contraseña'); return; }
  if(p !== PASSWORD){ alert('Contraseña incorrecta'); return; }
  if(p !== PASSWORD){ alert('Contraseña incorrecta'); document.getElementById('loginPass').value = ''; return; }
  currentUser = u;
  document.getElementById('hdrUser').innerText = `Usuario: ${u}`;
  document.getElementById('loginSection').style.display = 'none';
  document.getElementById('appSection').style.display = 'block';
  addRow();
}

// --- AGREGAR FILA ---
/* ----------------- INTERFAZ (tabla) ----------------- */
function addRow(){
  const tbody = document.querySelector('#tableWindows tbody');
  const tr = document.createElement('tr');
  const defaultLargo = parseInt(document.getElementById('globalLargo').value) || 6000;
  tr.innerHTML = `
    <td><input type="text" placeholder="V1"></td>
    <td><input type="number" placeholder="1500"></td>
    <td><input type="number" placeholder="1000"></td>
    <td><input type="number" value="1"></td>
    <td><input type="number" value="1" min="1"></td>
    <td><select>${Object.keys(SYSTEMS).map(s=>`<option value="${s}">${s}</option>`).join('')}</select></td>
    <td><input type="number" value="6000"></td>
    <td><input type="number" value="${defaultLargo}" min="1000"></td>
    <td><button class="btn ghost" onclick="this.closest('tr').remove()">X</button></td>
  `;
  tbody.appendChild(tr);
}
// --- OPTIMIZADOR DE CORTES (SOLVER EXACTO) ---
function optimizarCortesExacto(cortes, largoTira, merma = MERMA) {
  // cortes: array de longitudes requeridas
  // largoTira: largo máximo de cada barra
  // Retorna un array de tiras, cada una con cortes asignados y sobrante

  const piezas = cortes.map(c => c + merma).sort((a, b) => b - a);
/* ----------------- SOLVER EXACTO (backtracking) ----------------- */
function optimizarCortesExacto(cortes, largoTira, merma = MERMA) {
  // cortes: array de longitudes (mm) sin merma. El solver añadirá merma por pieza.
  // Se devuelve array de tiras: { cortes: [..], sobrante: number, largo: number }
  if(!cortes || cortes.length===0) return [];
  // piezas con merma incluida para asignación
  const piezas = cortes.map(c => c + merma).sort((a,b)=>b-a);
  let mejorSolucion = null;
  let menorSobranteTotal = Infinity;

  function backtrack(index, tiras) {
    if (index === piezas.length) {
      const sobranteTotal = tiras.reduce((s, t) => s + t.sobrante, 0);
      if (sobranteTotal < menorSobranteTotal) {
    if(index === piezas.length){
      const sobranteTotal = tiras.reduce((s,t)=>s + t.sobrante, 0);
      if(sobranteTotal < menorSobranteTotal){
        menorSobranteTotal = sobranteTotal;
        mejorSolucion = tiras.map(t => ({
          cortes: [...t.cortes],
          sobrante: t.sobrante,
          largo: t.largo
        }));
        mejorSolucion = tiras.map(t=>({ cortes:[...t.cortes], sobrante: t.sobrante, largo: t.largo }));
      }
      return;
    }

    const corte = piezas[index];

    // intentar colocar en tiras existentes
    for (let i = 0; i < tiras.length; i++) {
      if (tiras[i].sobrante >= corte) {
        tiras[i].cortes.push(corte - merma);
        tiras[i].sobrante -= corte;
        backtrack(index + 1, tiras);
        tiras[i].sobrante += corte;
    const pieza = piezas[index];
    // probar en tiras existentes
    for(let i=0;i<tiras.length;i++){
      if(tiras[i].sobrante >= pieza){
        tiras[i].cortes.push(pieza - merma);
        tiras[i].sobrante -= pieza;
        backtrack(index+1, tiras);
        tiras[i].sobrante += pieza;
        tiras[i].cortes.pop();
      }
    }

    // crear nueva tira
    if (corte <= largoTira) {
      const nueva = {
        cortes: [corte - merma],
        largo: largoTira,
        sobrante: largoTira - corte
      };
    // crear nueva tira si cabe
    if(pieza <= largoTira){
      const nueva = { cortes: [pieza - merma], largo: largoTira, sobrante: largoTira - pieza };
      tiras.push(nueva);
      backtrack(index + 1, tiras);
      backtrack(index+1, tiras);
      tiras.pop();
    }
  }
@@ -263,150 +225,170 @@ <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>
  return mejorSolucion || [];
}

// --- CALCULAR ---
/* ----------------- CALCULAR ----------------- */
function calcular(){
  const filas = [...document.querySelectorAll('#tableWindows tbody tr')];
  if(filas.length === 0){ alert('Agrega al menos una ventana'); return; }

  const data = [];
  filas.forEach(tr=>{
  const data = filas.map(tr=>{
    const tds = tr.querySelectorAll('td');
    data.push({
    return {
      winId: tds[0].querySelector('input').value.trim() || '-',
      alto: parseFloat(tds[1].querySelector('input').value)||0,
      ancho: parseFloat(tds[2].querySelector('input').value)||0,
      qty: parseInt(tds[3].querySelector('input').value)||1,
      alto: parseFloat(tds[1].querySelector('input').value) || 0,
      ancho: parseFloat(tds[2].querySelector('input').value) || 0,
      qty: parseInt(tds[3].querySelector('input').value) || 1,
      sistema: tds[4].querySelector('select').value,
      largo: parseFloat(tds[5].querySelector('input').value)||6000
    });
      largo: parseFloat(tds[5].querySelector('input').value) || 6000
    };
  });

  const resumenPorPerfil = {};
  const tirasPorPerfil = {};

  data.forEach(item=>{
  // calcular tiras por perfil usando solver exacto por cada perfil y cada ventana
  for(const item of data){
    const sys = SYSTEMS[item.sistema];
    if(!sys) return;
    if(!sys) continue;

    Object.entries(sys).forEach(([perfil, def])=>{
      // 🔹 Si es herraje, sumar unidades sin cortes
      if (def.tipo === "herraje") {
    for(const [perfil, def] of Object.entries(sys)){
      // herrajes: contabilizar por unidades (no generan cortes)
      if(def.tipo === "herraje"){
        const cantidadVentanas = item.qty || 1;
        const cantidadTotal = (def.cantidad || 1) * cantidadVentanas;
        resumenPorPerfil[perfil] = (resumenPorPerfil[perfil] || 0) + cantidadTotal;
        return;
        continue;
      }

      const cortes = [];
      for(let i=0;i<def.altos;i++) cortes.push(item.alto);
      const anchoCorte = def.dividirAncho ? item.ancho / 2 : item.ancho;
      for(let j=0;j<def.anchos;j++) cortes.push(anchoCorte);

      const totalCortes = cortes.length * item.qty;
      const largoTira = item.largo - MERMA;
     // --- OPTIMIZACIÓN EXACTA DE CORTES ---
const listaCortes = [];
for (let i = 0; i < def.altos; i++) listaCortes.push(item.alto);
const anchoCorte = def.dividirAncho ? item.ancho / 2 : item.ancho;
for (let j = 0; j < def.anchos; j++) listaCortes.push(anchoCorte);
const cortesTotales = [];
for (let i = 0; i < item.qty; i++) cortesTotales.push(...listaCortes);

// Ejecutar solver exacto
const tirasOptimas = optimizarCortesExacto(cortesTotales, item.largo, MERMA);

// Guardar resultados
resumenPorPerfil[perfil] = (resumenPorPerfil[perfil] || 0) + tirasOptimas.length;
tirasPorPerfil[perfil] = tirasPorPerfil[perfil] || [];

tirasOptimas.forEach((tira, idx) => {
  tirasPorPerfil[perfil].push({
    largo: item.largo,
    cortes: tira.cortes,
    winRefs: tira.cortes.map(() => item.winId),
    sobrante: tira.sobrante
   });
});
}); // 👈 esta llave cierra el data.forEach completo aquí
  // --- Calcular aprovechamiento ---
      // construir lista de cortes para este perfil (por una ventana)
      const cortesBase = [];
      for(let i=0;i<(def.altos||0);i++) cortesBase.push(item.alto);
      const anchoCorte = def.dividirAncho ? (item.ancho/2) : item.ancho;
      for(let j=0;j<(def.anchos||0);j++) cortesBase.push(anchoCorte);

      if(cortesBase.length === 0) continue;

      // replicar según cantidad de ventanas
      const cortesTotales = [];
      for(let k=0;k<item.qty;k++) cortesTotales.push(...cortesBase);

      // ejecutar solver exacto con largo de tira = item.largo (no restamos merma aquí porque solver lo considera)
      const tirasOptimas = optimizarCortesExacto(cortesTotales, item.largo, MERMA);

      // guardar resultado
      resumenPorPerfil[perfil] = (resumenPorPerfil[perfil] || 0) + tirasOptimas.length;
      tirasPorPerfil[perfil] = tirasPorPerfil[perfil] || [];
      tirasOptimas.forEach(t=>{
        // t.cortes ya está sin merma (porque así lo guardamos en solver)
        tirasPorPerfil[perfil].push({
          largo: t.largo,
          cortes: t.cortes,
          winRefs: t.cortes.map(()=>item.winId),
          sobrante: t.sobrante
        });
      });
    }
  }

  // calcular aprovechamiento total (solo perfiles, excluye herrajes)
  let totalUsado = 0;
  let totalDisponible = 0;
  Object.values(tirasPorPerfil).forEach(perfilTiras=>{
    perfilTiras.forEach(tira=>{
      const largoTira = tira.largo - MERMA;
  Object.values(tirasPorPerfil).forEach(lista=>{
    lista.forEach(tira=>{
      const largoTiraUtil = tira.largo - MERMA;
      const usado = tira.cortes.reduce((a,b)=>a+b,0);
      totalUsado += usado;
      totalDisponible += largoTira;
      totalDisponible += largoTiraUtil;
    });
  });
  const aprovechamiento = totalDisponible>0?(totalUsado/totalDisponible)*100:0;
  const aprovechamiento = totalDisponible > 0 ? (totalUsado/totalDisponible)*100 : 0;

  // calcular herrajes dependientes (calcularSegun) usando metros lineales de perfiles usados
  // Ejemplo: F04: calcularSegun: {"MTG2177":2, "MTG2176":1} => F04 = metros_lineales_de_MTg2177 * 2 + ...
  const resumenHerrajes = {};
  // primero copiar herrajes explícitos ya contados en resumenPorPerfil (si existen)
  for(const [perfil, defObj] of Object.entries(Object.assign({}, ...Object.values(SYSTEMS)) )) {
    // no usamos this loop; we'll compute from resumenPorPerfil and calcularSegun below
  }
  // aplicar reglas calcularSegun por sistema
  for(const [nombreSistema, perfiles] of Object.entries(SYSTEMS)){
    for(const [perfil, def] of Object.entries(perfiles)){
      if(def.tipo === "herraje" && def.calcularSegun){
        // sumar metros lineales de los perfiles base
        let totalMetros = 0;
        for(const [basePerfil, factor] of Object.entries(def.calcularSegun)){
          const tirasBase = tirasPorPerfil[basePerfil] || [];
          let sumaMm = 0;
          tirasBase.forEach(tira => sumaMm += tira.cortes.reduce((a,b)=>a+b,0));
          const metros = sumaMm / 1000;
          totalMetros += metros * factor;
        }
        // redondeo
        resumenHerrajes[perfil] = Math.round(totalMetros * 100) / 100;
      }
    }
  }
  // además sumar herrajes que vienen con cantidad fija (resumenPorPerfil ya tiene esas cantidades)
  for(const [perfil, def] of Object.entries(Object.assign({}, ...Object.values(SYSTEMS)))){
    // this is a helper - not used directly
  }
  // merge: si resumenPorPerfil tiene herrajes con cantidad directa, pasarlos a resumenHerrajes
  for(const [perfil, cantidad] of Object.entries(resumenPorPerfil)){
    // detectar si es realmente herraje (revisar SYSTEMS)
    let isHerraje = false;
    for(const sys of Object.values(SYSTEMS)){
      if(sys[perfil]?.tipo === "herraje") { isHerraje = true; break; }
    }
    if(isHerraje){
      // si ya existe en resumenHerrajes (por calcularSegun), sumar; si no, usar cantidad
      resumenHerrajes[perfil] = (resumenHerrajes[perfil] || 0) + cantidad;
    }
  }

  lastResults = { 
    proyecto: document.getElementById('projectName').value, 
    usuario: currentUser, 
    filas: data, 
    resumenPorPerfil, 
  // guardar resultados globales
  lastResults = {
    proyecto: document.getElementById('projectName').value || '',
    usuario: currentUser,
    filas: data,
    resumenPorPerfil,
    tirasPorPerfil,
    aprovechamiento
    aprovechamiento,
    resumenHerrajes
  };
// --- Cálculo dinámico de herrajes dependientes ---
Object.entries(SYSTEMS).forEach(([nombreSistema, perfiles]) => {
  Object.entries(perfiles).forEach(([perfil, def]) => {
    if (def.tipo === "herraje" && def.calcularSegun) {
      // Para cada sistema con reglas de cálculo
      let totalF04 = 0;

      // Recorremos los perfiles base definidos en calcularSegun
      Object.entries(def.calcularSegun).forEach(([basePerfil, factor]) => {
        const tiras = lastResults.tirasPorPerfil[basePerfil] || [];
        let sumaMm = 0;

        // Sumar todos los cortes usados de ese perfil
        tiras.forEach(tira => {
          sumaMm += tira.cortes.reduce((a, b) => a + b, 0);
        });

        // Convertir a metros lineales y aplicar el factor
        totalF04 += (sumaMm / 1000) * factor;
      });

      // Redondear a 2 decimales
      totalF04 = Math.round(totalF04 * 100) / 100;

      // Guardar el resultado como "cantidad" del herraje calculado
      resumenPorPerfil[perfil] = totalF04;
    }
  });
});

  // --- Mostrar resumen ---
  // --- Mostrar resumen en pantalla principal ---
  let html = `<b>Resumen de Ventanas:</b><br>`;
  data.forEach(f=>{
  data.forEach(f => {
    html += `${f.winId} = ${f.sistema} — Ancho: ${f.ancho} mm, Alto: ${f.alto} mm, Cant: ${f.qty}<br>`;
  });

  html += `<br><b>Tiras / Unidades por perfil:</b><br>`;
  Object.entries(resumenPorPerfil).forEach(([perfil, cant])=>{
    let esHerraje=false;
    for(const sistema in SYSTEMS){
      if(SYSTEMS[sistema][perfil]?.tipo==="herraje"){esHerraje=true;break;}
  Object.entries(resumenPorPerfil).forEach(([perfil,cant])=>{
    // determinar si es herraje
    let esHerraje = false;
    for(const sysName in SYSTEMS){
      if(SYSTEMS[sysName][perfil]?.tipo === "herraje"){ esHerraje = true; break; }
    }
    const etiqueta=esHerraje?"unidades":"tiras";
    const etiqueta = esHerraje ? "unidades" : "tiras";
    html += `${perfil}: ${cant} ${etiqueta}<br>`;
  });

  html += `<br><b>Aprovechamiento total:</b> ${aprovechamiento.toFixed(2)}%`;

  // si quieres ocultar aprovechamiento en pantalla y mostrar solo en PDF, cambia la línea anterior.
  document.getElementById('summary').innerHTML = html;
}

// --- EXPORTAR PDF ---
/* ----------------- EXPORTAR PDF ----------------- */
function exportPdf(){
  if(!lastResults){ alert('Calcule primero.'); return; }
  if(!lastResults){ alert('Calcula primero.'); return; }
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation:'landscape', unit:'pt', format:'a4' });
  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();
  const margin = 36;
  let y = margin;

  // Encabezado
  doc.setFontSize(16);
  doc.setTextColor(20,220,180);
  doc.text('OPTIMIZADOR DE CORTES - REPORTE TÉCNICO', pageW/2, y, {align:'center'});
@@ -419,6 +401,7 @@ <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>
  doc.text(`Fecha: ${new Date().toLocaleString()}`, pageW - margin - 160, y);
  y += 20;

  // Resumen de ventanas
  doc.setFontSize(11);
  doc.text('RESUMEN DE VENTANAS', margin, y);
  y += 12;
@@ -429,119 +412,105 @@ <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>
  });
  y += 10;

  // Aprovechamiento
  // Aprovechamiento (en PDF)
  doc.setFontSize(11);
  doc.setTextColor(0,100,0);
  doc.text(`Aprovechamiento total del material: ${lastResults.aprovechamiento.toFixed(2)}%`, margin, y);
  doc.setTextColor(0,0,0);
  y += 20;
// --- Resumen de herrajes y accesorios ---
doc.setFontSize(11);
doc.text('RESUMEN DE HERRAJES Y ACCESORIOS', margin, y);
y += 12;
doc.setFontSize(9);

// Filtramos solo los perfiles tipo "herraje"
const herrajes = Object.entries(lastResults.resumenPorPerfil).filter(([perfil])=>{
  for (const sistema in SYSTEMS){
    if (SYSTEMS[sistema][perfil]?.tipo === "herraje") return true;
  }
  return false;
});

if(herrajes.length === 0){
  doc.text('No se registraron herrajes.', margin, y);
  // Resumen de herrajes (solo en PDF)
  doc.setFontSize(11);
  doc.text('RESUMEN DE HERRAJES Y ACCESORIOS', margin, y);
  y += 12;
  doc.setFontSize(9);
  const herrajesEntries = Object.entries(lastResults.resumenHerrajes || {});
  if(herrajesEntries.length===0){
    doc.text('No se registraron herrajes.', margin, y); y += 10;
  } else {
    herrajesEntries.forEach(([codigo, valor])=>{
      doc.text(`${codigo}: ${Number(valor).toFixed(2)}`, margin, y); y += 10;
    });
  }
  y += 10;
}else{
  herrajes.forEach(([perfil, cant])=>{
    // Si este herraje tiene una regla de cálculo especial (calcularSegun)
    let detalle = '';
    for (const sistema in SYSTEMS){
      const def = SYSTEMS[sistema][perfil];
      if(def?.calcularSegun){
        const reglas = Object.entries(def.calcularSegun)
          .map(([base,f])=>`${base}×${f}`)
          .join(' + ');
        detalle = ` (calculado según ${reglas})`;
      }
    }
    doc.text(`${perfil}: ${cant} unidades${detalle}`, margin, y);
    y += 10;
  });
}

y += 20;

  // Diagramas de cortes por perfil (colorear por ventana ID)
  const barMaxWidth = Math.min(pageW - margin*2 - 160, 900);
  const barH = 14;
  const gap = 36;

  const perfiles = Object.keys(lastResults.tirasPorPerfil || {});
  perfiles.forEach(perfil=>{
    let esHerraje=false;
    for(const sistema in SYSTEMS){
      if(SYSTEMS[sistema][perfil]?.tipo==="herraje"){esHerraje=true;break;}
    }
    if(esHerraje) return;
  for(const perfil of perfiles){
    // saltar perfiles que sean herrajes (no graficar)
    let esHerraje = false;
    for(const s in SYSTEMS){ if(SYSTEMS[s][perfil]?.tipo === "herraje"){ esHerraje = true; break; } }
    if(esHerraje) continue;

    if(y > pageH - 120){ doc.addPage(); y = margin; }
    doc.setFontSize(11);
    doc.text(`${perfil} — Diagramas de corte`, margin, y);
    y += 10;

    (lastResults.tirasPorPerfil[perfil]||[]).forEach((tira,ti)=>{
    const tiras = lastResults.tirasPorPerfil[perfil] || [];
    tiras.forEach((tira, iT) => {
      if(y > pageH - 100){ doc.addPage(); y = margin; }
      const scale = barMaxWidth / tira.largo;
      let x = margin + 120;
      const baseY = y;

      // Etiqueta Tira n
      doc.setFontSize(9);
      doc.text(`Tira ${ti+1}`, margin + 60, baseY + barH/2 + 3, {align:'right'});
      doc.text(`Tira ${iT+1}`, margin + 60, baseY + barH/2 + 3, {align:'right'});

      doc.setDrawColor(100);
      doc.rect(x, baseY, barMaxWidth, barH);

      // cortes dentro de la tira
      for(let ci=0; ci<tira.cortes.length; ci++){
        const corte = tira.cortes[ci];
        const win = tira.winRefs[ci];
        const win = tira.winRefs[ci] || '-';
        const color = colorForId(win);
        const seg = corte * scale;

        doc.setFillColor(color[0],color[1],color[2]);
        doc.setFillColor(color[0], color[1], color[2]);
        doc.rect(x, baseY, seg, barH, 'F');

        const etiqueta = `${win} - ${corte} mm`;
        doc.setFontSize(8);
        doc.setTextColor(255,255,255);
        doc.text(etiqueta, x + seg/2, baseY + barH/2 + 3, {align:'center'});
        // intentar escribir en blanco si espacio suficiente
        if(seg > 36){ doc.setTextColor(255,255,255); doc.text(etiqueta, x + seg/2, baseY + barH/2 + 3, {align:'center'}); }
        else { doc.setTextColor(0,0,0); doc.text(etiqueta, x + seg/2, baseY - 2, {align:'center'}); }
        x += seg;
      }

      // sobrante
      if(tira.sobrante > 0){
        const sobraW = tira.sobrante * scale;
        doc.setFillColor(120,120,120);
        doc.rect(x, baseY, sobraW, barH, 'F');
        doc.setFontSize(8);
        doc.setTextColor(0,0,0);
        doc.text(`Sobrante ${tira.sobrante} mm`, x + sobraW/2, baseY + barH/2 + 3, {align:'center'});
        doc.text(`Sobrante ${tira.sobrante} mm`, x + Math.max(10, sobraW/2), baseY + barH/2 + 3, {align:'center'});
      }

      // etiqueta de tira utilizada
      doc.setFontSize(8);
      doc.setTextColor(0,0,0);
      doc.text(`Tira utilizada: ${tira.largo} mm`, margin + barMaxWidth/2, baseY + barH + 14, {align:'center'});
      y += gap;
    });
    y += 10;
  });
  
  doc.save(`Cortes_${Date.now()}.pdf`);
    y += 8;
  }

  // guardar
  doc.save(`Cortes_${(new Date()).toISOString().slice(0,19).replace(/[:T]/g,'_')}.pdf`);
}

// --- BORRAR TODO ---
/* ----------------- UTIL ----------------- */
function borrarTodo(){
  if(!confirm('¿Borrar todo?')) return;
  document.querySelector('#tableWindows tbody').innerHTML='';
  lastResults=null;
  document.getElementById('summary').innerText='Presiona "Calcular resumen" para ver totales por perfil.';
  document.querySelector('#tableWindows tbody').innerHTML = '';
  lastResults = null;
  document.getElementById('summary').innerText = 'Presiona "Calcular resumen" para ver totales por perfil.';
}

/* ----------------- FIN ----------------- */
</script>
</body>
</html>
