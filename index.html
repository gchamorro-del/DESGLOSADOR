<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Optimizador TÃ©cnico de Cortes â€” VersiÃ³n Final Mejorada (sin tablas en PDF)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1720; --text:#e6eef6; --muted:#98a2b3;
    --accent:#2ec4b6; --accent-2:#2b6df6; --danger:#ef4444; --border:#263039;
  }
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#071017,#071a2a);color:var(--text)}
  header{background:linear-gradient(90deg,var(--accent-2),#0366a6);padding:14px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid rgba(0,0,0,0.2)}
  header h1{margin:0;font-size:18px;color:#fff}
  .wrap{max-width:1200px;margin:18px auto;padding:12px}
  .panel{background:linear-gradient(180deg,#071820,#061017);border-radius:10px;padding:14px;border:1px solid var(--border)}
  label{color:var(--muted);font-size:13px}
  input, select, button, textarea{font-size:14px}
  input[type="text"], input[type="number"], select, textarea{width:100%;padding:8px;border-radius:6px;border:1px solid #22303a;background:#071018;color:var(--text)}
  table{width:100%;border-collapse:collapse;margin-top:10px;background:transparent}
  th,td{padding:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px;color:var(--text);text-align:center}
  th{background:rgba(255,255,255,0.03);color:var(--muted)}
  .row{display:flex;gap:10px}
  .col{flex:1}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .btn{background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#041018;padding:8px 12px;border-radius:6px;border:none;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
  .btn.danger{background:var(--danger);color:#fff}
  #summary{margin-top:12px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#071319,#061018);color:var(--text)}
  .muted{color:var(--muted);font-size:13px}
  .login-box{max-width:520px;margin:80px auto;padding:18px;border-radius:10px;background:linear-gradient(180deg,#071014,#081218);border:1px solid var(--border)}
  .center{text-align:center}
  .small{font-size:12px;color:var(--muted)}
  @media(max-width:860px){ .row{flex-direction:column} .col{width:100%} }
</style>
</head>
<body>
<header>
  <h1>ðŸ”© Optimizador TÃ©cnico de Cortes â€” VersiÃ³n Final</h1>
  <div id="hdrUser" class="small">Offline â€¢ Tema tÃ©cnico</div>
</header>

<div class="wrap">
  <!-- LOGIN -->
  <div id="loginSection" class="login-box panel">
    <h2 style="color:var(--text);margin:0 0 8px 0">Acceso</h2>
    <div class="row" style="gap:8px">
      <div class="col">
        <label for="loginUser">Usuario (nombre):</label>
        <input id="loginUser" type="text" placeholder="Ej. Gustavo Chamorro">
      </div>
      <div style="width:180px">
        <label for="loginPass">ContraseÃ±a:</label>
        <input id="loginPass" type="password" placeholder="ContraseÃ±a">
      </div>
    </div>
    <div style="margin-top:12px" class="actions">
      <button class="btn" id="loginBtn">Entrar</button>
    </div>
    <p class="small" style="margin-top:10px;color:var(--muted)">ContraseÃ±a fija por defecto: <b>1234</b></p>
  </div>

  <!-- APP -->
  <div id="appSection" style="display:none">
    <div class="panel">
      <div class="row" style="align-items:center;gap:12px">
        <div class="col" style="max-width:400px;">
          <label for="projectName">Proyecto / Cliente</label>
          <input id="projectName" type="text" placeholder="Ej. Proyecto Alfa - Edificio A">
        </div>
        <div style="width:260px">
          <label>&nbsp;</label>
          <div class="actions">
            <button class="btn" onclick="addRow()">âž• Agregar ventana</button>
            <button class="btn ghost" onclick="calcular()">ðŸ§® Calcular resumen</button>
            <button class="btn" onclick="exportPdf()">ðŸ“„ Exportar PDF</button>
            <button class="btn danger" onclick="borrarTodo()">ðŸ—‘ Borrar todo</button>
          </div>
        </div>
      </div>

      <h3 style="margin-top:14px;color:var(--accent)">Ventanas (ingreso manual)</h3>

      <div id="summary" class="muted center" aria-live="polite">Presiona "Calcular resumen" para ver totales por perfil.</div>

      <table id="tableWindows">
        <thead>
          <tr>
            <th>ID Ventana</th>
            <th>Ancho (mm)</th>
            <th>Alto (mm)</th>
            <th>Cantidad</th>
            <th>Sistema</th>
            <th>Largo Tira (mm) [override]</th>
            <th>Eliminar</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PASSWORD="1234";
  const MERMA=50;
  let currentUser=null;
  let lastResults=null;

  const SYSTEMS={
    "Ventana Corrediza Europea 3V (3 Hojas)":{
      "MTG1399":{altos:2,anchos:2},
      "MTG2177":{altos:6,anchos:6,dividirAncho:true},
      "MTG2176":{altos:4,anchos:0},
      "F04":{tipo:"herraje",calcularSegun:{"MTG2177":2,"MTG2176":1}},
      "EUAA05L":{cantidad:20,tipo:"herraje"},
      "EUAP01":{cantidad:1.5,tipo:"herraje"},
      "EUCH01":{cantidad:2,tipo:"herraje"},
      "EUCH02":{cantidad:2,tipo:"herraje"}
    },
    "Ventana Europea Fija":{
      "MTG2180":{altos:2,anchos:2},
      "MTG2184":{altos:2,anchos:2},
      "EUAA01":{cantidad:4,tipo:"herraje"}
    },
    "Ventana Corrediza Europea 3V (2 Hojas + Cedazo)":{
      "MTG1399":{altos:2,anchos:2},
      "MTG2177":{altos:4,anchos:4,dividirAncho:true},
      "MTG2078":{altos:2,anchos:2,dividirAncho:true}, 
      "MTG2176":{altos:4,anchos:0},
      "F04":{tipo:"herraje",calcularSegun:{"MTG2177":2,"MTG2176":1}},
      "EUAA05L":{cantidad:20,tipo:"herraje"},
      "EUAP01":{cantidad:1.5,tipo:"herraje"},
      "EUCH01":{cantidad:2,tipo:"herraje"},
      "EUCH02":{cantidad:2,tipo:"herraje"}
    },
    "Batiente":{},
    "ProyecciÃ³n":{},
    "Otro":{}
  };

  /* LOGIN */
  document.getElementById('loginBtn').addEventListener('click',()=>{
    const u=document.getElementById('loginUser').value.trim();
    const p=document.getElementById('loginPass').value;
    if(!u||!p){alert('Ingrese usuario y contraseÃ±a');return;}
    if(p!==PASSWORD){alert('ContraseÃ±a incorrecta');document.getElementById('loginPass').value='';return;}
    currentUser=u;
    document.getElementById('hdrUser').innerText=`Usuario: ${u}`;
    document.getElementById('loginSection').style.display='none';
    document.getElementById('appSection').style.display='block';
    addRow();
  });

  /* INTERFAZ */
  function addRow(){
    const tbody=document.querySelector('#tableWindows tbody');
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td><input type="text" placeholder="V1"></td>
      <td><input type="number" placeholder="1000" min="0"></td>
      <td><input type="number" placeholder="1500" min="0"></td>
      <td><input type="number" value="1" min="1"></td>
      <td><select>${Object.keys(SYSTEMS).map(s=>`<option value="${s}">${s}</option>`).join('')}</select></td>
      <td><input type="text" placeholder="Ej: 5000,6000"></td>
      <td><button class="btn ghost" onclick="this.closest('tr').remove()">X</button></td>`;
    tbody.appendChild(tr);
  }

  /* COLOR */
  function colorForId(id){
    const hash=[...String(id)].reduce((a,c)=>a+c.charCodeAt(0),0);
    const hue=hash%360;
    return hslToRgb(hue/360,0.65,0.5);
  }
  function hslToRgb(h,s,l){
    let r,g,b;
    if(s==0){r=g=b=l;}
    else{
      const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};
      const q=l<0.5?l*(1+s):l+s-l*s;
      const p=2*l-q;
      r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);
    }
    return[Math.round(r*255),Math.round(g*255),Math.round(b*255)];
  }
/* ======================================================================= */
/* ===================  SOLVER FFD + MEJORAS LOCALES  ===================== */
/* ======================================================================= */

// (Funciones de empaquetado idÃ©nticas al original: solveCutsMultiLargo, ffdRun, consolidateQuick)
// Para brevedad las mantengo sin cambios (se omiten aquÃ­ solo por limpieza visual en el ejemplo)

function solveCutsMultiLargo(piezas, largosDisponibles, merma=MERMA){
  if(!Array.isArray(piezas) || piezas.length===0) return [];
  const largosLimpios = [...new Set((largosDisponibles||[]).map(v=>parseInt(v)).filter(n=>!isNaN(n)&&n>0))];
  const largosBase = (largosLimpios.length? largosLimpios : [6000]);
  const resDesc = ffdRun(piezas, [...largosBase].sort((a,b)=>b-a), merma);
  const resAsc  = ffdRun(piezas, [...largosBase].sort((a,b)=>a-b), merma);
  const score = (bins)=> {
    const usado = bins.reduce((s,b)=>s+(b.utilizada ?? b.piezas.reduce((a,p)=>a+p.len,0)),0);
    const disp  = bins.reduce((s,b)=>s+b.largo,0);
    return disp>0 ? usado/disp : 0;
  };
  const best = score(resAsc) > score(resDesc) ? resAsc : resDesc;
  consolidateQuick(best, merma);
  best.forEach((b,i)=>{ b.id = i+1; b.utilizada = b.piezas.reduce((a,p)=>a+p.len,0); });
  return best;
}

function ffdRun(piezas, largosOrdenados, merma){
  const items = piezas.map(p=>({winId:p.winId, len:Number(p.len)})).filter(p=>p.len>0).sort((a,b)=>b.len-a.len);
  const bins = [];
  const leftovers = [];
  const tryPlaceInLeftovers = (lenNeed)=>{
    for(let i=0;i<leftovers.length;i++){
      if(leftovers[i] >= lenNeed){
        leftovers[i] -= lenNeed;
        if(leftovers[i] < 20) leftovers.splice(i,1);
        return true;
      }
    }
    return false;
  };
  const tryPlaceInBins = (piece)=>{
    const need = piece.len + merma;
    for(const b of bins){
      if(b.restante >= need){
        b.piezas.push(piece);
        b.restante -= need;
        b.utilizada += piece.len;
        return true;
      }
    }
    return false;
  };
  const chooseBarLength = (need)=>{
    for(const L of largosOrdenados){
      if(L >= need) return L;
    }
    return Math.max(need, largosOrdenados[largosOrdenados.length-1] || 6000);
  };
  const greedyFill = (bin)=>{
    let changed = true;
    while(changed){
      changed = false;
      for(let i=items.length-1; i>=0; i--){
        const p = items[i];
        const need = p.len + merma;
        if(bin.restante >= need){
          bin.piezas.push(p);
          bin.restante -= need;
          bin.utilizada += p.len;
          items.splice(i,1);
          changed = true;
        }
      }
    }
  };
  while(items.length){
    const piece = items.shift();
    const need = piece.len + merma;
    if(tryPlaceInLeftovers(need)) continue;
    if(tryPlaceInBins(piece)) continue;
    const L = chooseBarLength(need);
    const bin = { piezas:[piece], largo:L, restante:L-need, utilizada:piece.len };
    bins.push(bin);
    greedyFill(bin);
  }
  for(const b of bins){
    if(b.restante > 20) leftovers.push(b.restante);
  }
  bins.forEach((b,i)=>{ b.id=i+1; b.utilizada ??= b.piezas.reduce((a,p)=>a+p.len,0); });
  return bins;
}

function consolidateQuick(bins, merma){
  if(bins.length < 2) return;
  bins.sort((a,b)=>b.restante - a.restante);
  const worst = bins[0];
  if(!worst || worst.piezas.length<=1) return;
  const piezasOrdenadas = [...worst.piezas].sort((a,b)=>a.len-b.len);
  let moved = false;
  for(const p of piezasOrdenadas){
    const need = p.len + merma;
    for(let j=1;j<bins.length;j++){
      const target = bins[j];
      if(target.restante >= need){
        const idx = worst.piezas.findIndex(x=>x===p);
        if(idx>=0){
          worst.piezas.splice(idx,1);
          worst.utilizada -= p.len;
          worst.restante += need;
        }
        target.piezas.push(p);
        target.utilizada += p.len;
        target.restante -= need;
        moved = true;
        break;
      }
    }
    if(moved) break;
  }
  if(worst.piezas.length===0){
    const k = bins.indexOf(worst);
    if(k>=0) bins.splice(k,1);
  }
}

/* ================== CALCULAR =================== */
function calcular(){
 const filas=[...document.querySelectorAll('#tableWindows tbody tr')];
 if(filas.length===0){alert('Agrega al menos una ventana');return;}

 const piezasPorPerfil={},resumenHerrajes={},resumenVentanas={};
 const perfilLargosMap={}; // perfil -> Set()

 let totalUsado=0,totalDisponible=0;
 const resumenPorPerfil={},resumenPorLargo={},tirasPorPerfil={};

 for(const tr of filas){
  const tds=tr.querySelectorAll('td');
  const winId=tds[0].querySelector('input').value.trim()||'-';
  const ancho=parseFloat(tds[1].querySelector('input').value)||0;
  const alto=parseFloat(tds[2].querySelector('input').value)||0;
  const qty=parseInt(tds[3].querySelector('input').value)||1;
  const sistema=tds[4].querySelector('select').value;

  const rawRow=(tds[5].querySelector('input').value||'').split(',').map(s=>s.trim()).filter(s=>s.length>0);
  const rowLargos=[...new Set(rawRow.map(v=>parseInt(v)).filter(n=>!isNaN(n)&&n>0))];
  const rowLargosFinal = rowLargos.length ? rowLargos : [6000];

  const sys=SYSTEMS[sistema]||{};
  if(!resumenVentanas[winId])resumenVentanas[winId]={ancho,alto,qty:0};
  resumenVentanas[winId].qty+=qty;

  for(const [perfil,def] of Object.entries(sys)){
    if(def.tipo==="herraje"){
      const cantidadTotal=(def.cantidad||1)*qty;
      resumenHerrajes[perfil]=(resumenHerrajes[perfil]||0)+cantidadTotal;
      continue;
    }
    const cortes=[];for(let i=0;i<(def.altos||0);i++)cortes.push(alto);
    const anchoCorte=def.dividirAncho?Math.round(ancho/2):ancho;
    for(let i=0;i<(def.anchos||0);i++)cortes.push(anchoCorte);

    if(!piezasPorPerfil[perfil]) piezasPorPerfil[perfil]=[];
    if(!perfilLargosMap[perfil]) perfilLargosMap[perfil]=new Set();
    rowLargosFinal.forEach(L=>perfilLargosMap[perfil].add(L));

    for(let q=0;q<qty;q++){
      cortes.forEach(len=>piezasPorPerfil[perfil].push({winId,len}));
    }
  }
 }

 for(const [perfil,piezas] of Object.entries(piezasPorPerfil)){
  const largos = Array.from(perfilLargosMap[perfil]||[]);
  const largosParaPerfil = (largos.length? largos : [6000]);
  const bins=solveCutsMultiLargo(piezas,largosParaPerfil,MERMA);

  tirasPorPerfil[perfil]={tiras:bins};
  resumenPorPerfil[perfil]=bins.length;

  for(const b of bins){
    totalUsado+=b.utilizada||b.piezas.reduce((a,p)=>a+p.len,0);
    totalDisponible+=b.largo;
    resumenPorLargo[b.largo]=(resumenPorLargo[b.largo]||0)+1;
  }
 }

 const aprovechamiento=totalDisponible>0?(totalUsado/totalDisponible)*100:0;
 lastResults={
  proyecto:document.getElementById('projectName').value||'',
  usuario:currentUser||'',
  resumenPorPerfil,
  resumenPorLargo,
  resumenHerrajes,
  resumenVentanas,
  tirasPorPerfil,
  aprovechamiento,
  totalUsado,
  totalDisponible
 };

 let html=`<b>RESUMEN DE VENTANAS (ID = Ancho Ã— Alto, Cantidad)</b><br>`;
 Object.entries(resumenVentanas).forEach(([id,v])=>{html+=`${id}: ${v.ancho} Ã— ${v.alto} mm, Cantidad: ${v.qty}<br>`;});
 html+=`<br><b>RESUMEN DE HERRAJES Y ACCESORIOS</b><br>`;
 Object.entries(resumenHerrajes).forEach(([k,v])=>{html+=`${k}: ${Number(v).toFixed(2)}<br>`;});
 html+=`<br><b>RESUMEN DE TIRAS POR PERFIL</b><br>`;
 Object.entries(resumenPorPerfil).forEach(([perfil,cant])=>{html+=`${perfil}: ${cant} tiras<br>`;});
 html+=`<br><b>RESUMEN POR LARGO DE TIRA</b><br>`;
 Object.keys(resumenPorLargo).map(k=>parseInt(k)).sort((a,b)=>b-a).forEach(l=>{html+=`${resumenPorLargo[l]} tiras de ${l} mm<br>`;});
 html+=`<br><b>Total usado:</b> ${totalUsado.toFixed(0)} mm<br><b>Total disponible:</b> ${totalDisponible.toFixed(0)} mm<br><b>Aprovechamiento:</b> ${aprovechamiento.toFixed(2)}%`;
 document.getElementById('summary').innerHTML=html;
}

/* ================== EXPORTAR PDF (inicio mÃ¡s a la izquierda + priorizar piezas sobre sobrante) =================== */
function exportPdf() {
  if (!lastResults || !lastResults.tirasPorPerfil) {
    alert('Primero presiona Calcular resumen.');
    return;
  }

  try {
    const { jsPDF } = window.jspdf;

    // PDF Letter Landscape (apto para impresiÃ³n en carta horizontal)
    const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'letter' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 28;
    let y = margin;

    // ---------- Encabezado ----------
    doc.setFontSize(16);
    doc.setTextColor(20);
    doc.text('OPTIMIZADOR DE CORTES - REPORTE TÃ‰CNICO', pageW / 2, y, { align: 'center' });
    y += 20;
    doc.setFontSize(10);
    doc.text(`Proyecto: ${lastResults.proyecto || '-'}`, margin, y);
    doc.text(`Usuario: ${lastResults.usuario || '-'}`, margin + 260, y);
    doc.text(`Fecha: ${new Date().toLocaleString()}`, pageW - margin - 220, y);
    y += 16;
    doc.line(margin, y, pageW - margin, y);
    y += 14;

    // ---------- ResÃºmenes (texto simple) ----------
    doc.setFontSize(12);
    doc.text('RESUMEN DE VENTANAS', margin, y);
    y += 14;
    Object.entries(lastResults.resumenVentanas || {}).forEach(([id, v]) => {
      doc.setFontSize(10);
      doc.text(`${id}: ${v.ancho} Ã— ${v.alto} mm â€” Cantidad: ${v.qty}`, margin, y);
      y += 12;
    });

    y += 6;
    doc.setFontSize(12);
    doc.text('RESUMEN DE HERRAJES Y ACCESORIOS', margin, y);
    y += 14;
    Object.entries(lastResults.resumenHerrajes || {}).forEach(([k, v]) => {
      doc.setFontSize(10);
      doc.text(`${k}: ${Number(v).toFixed(2)}`, margin, y);
      y += 12;
    });

    y += 6;
    doc.setFontSize(12);
    doc.text('RESUMEN DE TIRAS POR PERFIL Y LARGO', margin, y);
    y += 14;
    Object.entries(lastResults.resumenPorPerfil || {}).forEach(([perfil, cant]) => {
      doc.setFontSize(10);
      doc.text(`${perfil}: ${cant} tiras`, margin, y);
      y += 12;
    });

    y += 8;
    doc.setFontSize(10);
    doc.text(`Aprovechamiento total: ${lastResults.aprovechamiento.toFixed(2)}%`, margin, y);
    y += 20;

    /* ===========================================================
       AquÃ­ viene la mejora solicitada:
       - las barras empiezan lo mÃ¡s a la izquierda posible (pero dejando lugar para el texto)
       - prioridad: mostrar los cortes (piezas) y sus etiquetas; el texto de "Sobrante" se dibuja
         sÃ³lo si hay espacio suficiente (si no, se pinta sÃ³lo la franja gris).
    =========================================================== */

    // ParÃ¡metros de control (ajusta si quieres empezar incluso mÃ¡s a la izquierda)
    const minimalLeftSpace = 48;   // distancia mÃ­nima desde el borde para textos (flecha roja ~ aquÃ­)
    const paddingBetweenTextAndBar = 8; // pequeÃ±a separaciÃ³n entre la columna izquierda y la barra

    // Calculamos ancho requerido por etiquetas largas de perfil (pero limitamos)
    doc.setFontSize(12);
    let maxLabelW = 0;
    Object.keys(lastResults.tirasPorPerfil || {}).forEach(perf => {
      const test = `${perf} â€” Diagramas (99 tiras)`;
      const w = doc.getTextWidth(test);
      if (w > maxLabelW) maxLabelW = w;
    });

    // Queremos iniciar la barra lo mÃ¡s a la izquierda posible, preferimos un pequeÃ±o offset
    // en lugar de usar todo el ancho de la etiqueta (esto es donde apunta la flecha roja).
    // containerX = margin + leftOffset, donde leftOffset es el mÃ­nimo entre:
    // - un valor deseado (minimalLeftSpace)
    // - la anchura de la etiqueta si es mayor que ese valor
    const leftOffset = Math.max(minimalLeftSpace, Math.min(maxLabelW + paddingBetweenTextAndBar, pageW * 0.001));
    const containerX = margin + leftOffset;

    // ancho util de la barra (no debe pasar del margen derecho)
    const barW = Math.max(40, pageW - containerX - margin);

    // parÃ¡metros base para dibujo de barras
    const baseBarH = 20;
    const baseGap = 36;
    const baseMinW = 30; // ancho mÃ­nimo por segmento; lo reducimos agresivamente si es necesario

    // Recorremos perfiles y tiras
    for (const [perfil, obj] of Object.entries(lastResults.tirasPorPerfil || {})) {
      const allTiras = obj.tiras || [];
      if (!allTiras || allTiras.length === 0) continue;

      // Si queda poco espacio vertical, paginamos
      if (y > pageH - 160) { doc.addPage(); y = margin; }

      // dibujamos el nombre del perfil en la columna de la izquierda (alineado con margen)
      doc.setFontSize(12);
      doc.text(`${perfil} â€” Diagramas (${allTiras.length} tiras)`, margin, y);
      y += 12;

      // agrupar tiras idÃ©nticas
      const tirasMap = new Map();
      for (const t of allTiras) {
        const clave = JSON.stringify(t.piezas.map(p => `${p.winId}-${p.len}`)) + '|' + t.largo;
        if (!tirasMap.has(clave)) tirasMap.set(clave, { ...t, count: 1 });
        else tirasMap.get(clave).count++;
      }
      const tiras = Array.from(tirasMap.values());

      for (let i = 0; i < tiras.length; i++) {
        const t = tiras[i];

        // Preparar tamaÃ±os y escala
        const piezasLen = (t.piezas || []).map(p => p.len);
        const totalLen = piezasLen.reduce((a, b) => a + b, 0) || Math.max(1, t.largo || 6000);

        // arrancamos con parÃ¡metros base
        let minW = baseMinW;
        let barH = baseBarH;
        let gap = baseGap;

        // escala tentativa
        let scale = (barW - minW * piezasLen.length) / totalLen;
        let tries = 0;
        while (scale <= 0 && tries < 6) {
          tries++;
          minW = Math.max(6, Math.floor(minW * 0.75)); // reducir mÃ­nimo por segmento
          barH = Math.max(10, Math.floor(barH * 0.9));
          gap = Math.max(8, Math.floor(gap * 0.85));
          scale = (barW - minW * piezasLen.length) / totalLen;
        }

        // Si aun asÃ­ no cabe, permitimos wrap (varias filas)
        let wrapRows = 1;
        if (scale <= 0) {
          const approxPerRow = Math.max(1, Math.floor(barW / (minW + 1)));
          wrapRows = Math.ceil(piezasLen.length / approxPerRow);
          barH = Math.max(10, Math.floor(barH / wrapRows));
        }

        // comprobar paginaciÃ³n vertical
        const neededV = wrapRows * (barH + 16) + 28;
        if (y + neededV > pageH - 80) { doc.addPage(); y = margin; }

        // ETIQUETA de la tira centrada arriba de la barra
        const label = `Tira ${i + 1} (${t.largo} mm)` + (t.count > 1 ? ` Ã—${t.count}` : '');
        doc.setFontSize(9);
        doc.text(label, containerX + barW / 2, y, { align: 'center' });
        y += 8;

        // DIBUJAR filas (si wrapRows > 1)
        let idx = 0;
        for (let row = 0; row < wrapRows; row++) {
          const piezasPorFila = Math.ceil(piezasLen.length / wrapRows);
          const chunk = (t.piezas || []).slice(idx, idx + piezasPorFila);
          const chunkLen = chunk.map(p => p.len).reduce((a, b) => a + b, 0) || 1;
          const scaleRow = Math.max(0.0001, (barW - minW * chunk.length) / chunkLen);

          // contenedor de barra (inicio en containerX)
          doc.setDrawColor(0);
          doc.rect(containerX, y, barW, barH);

          let x = containerX;

          // dibujar segmentos y sus etiquetas (prioridad: SIEMPRE mostrar p.winId y longitud)
          for (const p of chunk) {
            const seg = Math.max(minW, Math.round(minW + p.len * scaleRow));
            const color = colorForId(p.winId);
            doc.setFillColor(color[0], color[1], color[2]);
            doc.rect(x, y, seg, barH, 'F');

            // etiquetas debajo del segmento (prioritarias)
            doc.setFontSize(7);
            doc.setTextColor(30);
            // si el segmento es muy estrecho, aÃºn asÃ­ colocamos las etiquetas (pueden superponerse)
            // porque el requerimiento es priorizarlas sobre el texto de sobrante
            doc.text(p.winId, x + seg / 2, y + barH + 8, { align: 'center' });
            doc.text(`${p.len} mm`, x + seg / 2, y + barH + 16, { align: 'center' });

            // lÃ­nea divisoria visual
            doc.setDrawColor(0);
            doc.line(x + seg, y, x + seg, y + barH);

            x += seg;
          }

          // Sobrante: lo pintamos siempre (franja gris) pero **solo mostramos su texto
          // si hay suficiente anchura** (no queremos que el texto de sobrante oculte las piezas)
          const restante = Math.round(t.restante || 0);
          if (restante > 0) {
            const sobraW = Math.round((restante / t.largo) * barW);
            // pintar franja gris al final
            doc.setFillColor(210);
            // si sobraW supera el ancho de la barra, limitamos
            const drawSobraW = Math.max(0, Math.min(sobraW, barW - 2));
            doc.rect(containerX + barW - drawSobraW, y, drawSobraW, barH, 'F');

            // mostrar texto de sobrante SOLO si drawSobraW es lo bastante ancho
            // (prioridad: piezas primero; aumente este umbral si quiere mÃ¡s seguridad)
            const thresholdSobraForLabel = 140; // puntos
            if (drawSobraW > thresholdSobraForLabel) {
              doc.setFontSize(8);
              doc.setTextColor(20);
              doc.text(`Sobrante ${restante} mm`, containerX + barW - drawSobraW / 2, y + barH / 2 + 4, { align: 'center' });
            }
          }

          // avanzar vertical a la siguiente fila del mismo t
          y += barH + 18;
          idx += piezasPorFila;
        } // end row

        // espacio entre tiras
        y += Math.max(6, gap - 20);
      } // end each tira

      y += 8;
    } // end each perfil

    // ---------- Pie de pÃ¡gina ----------
    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(100);
      doc.text(`PÃ¡gina ${i} de ${totalPages} â€” Generado por Optimizador TÃ©cnico de Cortes`, pageW / 2, pageH - 14, { align: 'center' });
    }

    // Guardar
    doc.save(`Reporte_Cortes_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '_')}.pdf`);
  } catch (err) {
    console.error('Error en exportPdf:', err);
    alert('Error al generar PDF.');
  }
}

// ðŸ”½ FUNCION BORRAR TODO
function borrarTodo(){
  if(!confirm('Â¿Borrar todo?'))return;
  document.querySelector('#tableWindows tbody').innerHTML='';
  lastResults=null;
  document.getElementById('summary').innerText='Presiona "Calcular resumen" para ver totales por perfil.';
  localStorage.removeItem('cortesApp');
}

// ðŸ”½ agrega esto al final del bloque
window.addRow = addRow;
window.calcular = calcular;
window.exportPdf = exportPdf;
window.borrarTodo = borrarTodo;

}); // cierre del DOMContentLoaded
</script>
</body>
</html>
